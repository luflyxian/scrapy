# -*- coding: utf-8 -*-
import hmac
import math
import threading
from urllib import parse
from uuid import uuid4

import requests
import redis
import json
import time
import datetime
from pprint import pprint
import pymysql
from hashlib import md5
import re
import threadpool
import random
from queue import Queue
import execjs

js2 = """
    function get_token(arg1){
var _0x5e8b26 = "3000176000856006061501533003690027800375";

String["prototype"]["hexXor"] = function (_0x4e08d8) {
    var _0x5a5d3b = "";

    for (var _0xe89588 = 0; _0xe89588 < this["length"] && _0xe89588 < _0x4e08d8["length"]; _0xe89588 += 2) {
        var _0x401af1 = parseInt(this["slice"](_0xe89588, _0xe89588 + 2), 16);

        var _0x105f59 = parseInt(_0x4e08d8["slice"](_0xe89588, _0xe89588 + 2), 16);

        var _0x189e2c = (_0x401af1 ^ _0x105f59)["toString"](16);

        if (_0x189e2c["length"] == 1) {
            _0x189e2c = "0" + _0x189e2c;
        }

        _0x5a5d3b += _0x189e2c;
    }

    return _0x5a5d3b;
};

String["prototype"]["unsbox"] = function () {
    var _0x4b082b = [15, 35, 29, 24, 33, 16, 1, 38, 10, 9, 19, 31, 40, 27, 22, 23, 25, 13, 6, 11, 39, 18, 20, 8, 14, 21, 32, 26, 2, 30, 7, 4, 17, 5, 3, 28, 34, 37, 12, 36];
    var _0x4da0dc = [];
    var _0x12605e = "";

    for (var _0x20a7bf = 0; _0x20a7bf < this["length"]; _0x20a7bf++) {
        var _0x385ee3 = this[_0x20a7bf];

        for (var _0x217721 = 0; _0x217721 < _0x4b082b["length"]; _0x217721++) {
            if (_0x4b082b[_0x217721] == _0x20a7bf + 1) {
                _0x4da0dc[_0x217721] = _0x385ee3;
            }
        }
    }

    _0x12605e = _0x4da0dc["join"]("");
    return _0x12605e;
};

var _0x23a392 = arg1["unsbox"]();

arg2 = _0x23a392["hexXor"](_0x5e8b26);
return arg2
        }
    """

three_size_mapping = {"其他": 68946, "销售代表": 62438, "销售经理": 41830, "普工/操作工": 32104, "客服专员/助理": 28328,
                      "质检员/测试员(QC)": 25457, "大客户销售": 24662, "销售工程师": 23563, "机械工程师": 23171, "会计": 21290, "人事专员": 21166,
                      "行政专员/助理": 20801, "采购员": 20358, "质量管理/测试工程师(QA/QC工程师)": 20328, "产品工艺/制程工程师": 20161,
                      "区域销售经理": 19861, "电话销售": 17759, "仓库管理员": 17741, "售前/售后技术支持工程师": 17724, "生物工程/生物制药": 16490,
                      "电气工程师/技术员": 16437, "销售助理": 16371, "文员": 15197, "电商运营": 14781, "市场/营销/拓展专员": 14778, "电工": 13767,
                      "产品经理/主管": 13504, "医药代表": 13466, "市场/营销/拓展经理": 13230, "店员/营业员": 13080, "生产计划/物料管理(PMC)": 12916,
                      "软件工程师": 12847, "送餐员": 12493, "嵌入式软件开发(Linux/单片机/PLC/DSP…)": 12388, "货运司机": 12382, "销售主管": 11834,
                      "项目经理": 11732, "工程/设备工程师": 11220, "Java开发工程师": 11160, "新媒体运营": 10830, "销售总监": 10530,
                      "储备干部": 10419, "技工": 10402, "结构工程师": 10287, "门店经理/店长": 9950, "贸易/外贸专员/助理": 9792, "技术研发工程师": 9722,
                      "出纳员": 9603, "技术支持/维护工程师": 9316, "平面设计师": 9293, "财务经理": 9283, "总裁助理/总经理助理": 9095,
                      "前台接待/总机/接待生": 8947, "房地产销售": 8808, "房地产中介/置业顾问": 8679, "维修工程师": 8582, "区域销售代表": 8577,
                      "质量管理/测试经理(QA/QC经理)": 8330, "Web前端开发": 8168, "财务助理/财务文员": 8109, "项目管理": 7998, "运维工程师": 7977,
                      "化工技术应用/化工工程师": 7951, "大学/大专应届毕业生": 7918, "业务拓展主管/经理": 7897, "人事经理": 7893, "人事主管": 7879,
                      "保安人员": 7794, "渠道/分销专员": 7780, "行政经理/主管/办公室主任": 7775, "网络销售/在线销售": 7673,
                      "质量管理/测试主管(QA/QC主管)": 7672, "商务司机": 7638, "招聘专员/助理": 7530, "安全员": 7343, "文案/策划": 7328,
                      "生产主管": 7319, "医药销售人员": 7252, "招商/租赁/租售": 7201, "财务主管/总账主管": 7166, "物业管理经理": 7082,
                      "生产领班/组长": 7053, "门店销售": 6872, "医疗器械销售代表": 6778, "工程造价师/预结算经理": 6737, "硬件工程师": 6702, "后勤": 6692,
                      "商务助理": 6604, "生产经理/车间主任": 6603, "网络/在线客服": 6533, "环境/健康/安全工程师（EHS）": 6514, "电子工程师/技术员": 6492,
                      "体系工程师": 6428, "商务主管/专员": 6348, "运营专员": 6181, "化工实验室研究员/技术员": 6160, "C/C++开发工程师": 6145,
                      "建筑工程管理/项目经理": 6097, "室内设计": 6058, "货运代理": 6043, "护士/护理人员": 6019, "数控操机": 6009,
                      "网络工程师(IT工程师)": 5883, "药品生产/质量管理": 5861, "实习生": 5844, "机械设计": 5830, "专业顾问": 5801, "物流专员/助理": 5733,
                      "业务跟单": 5597, "工业设计/产品设计": 5548, "仓库经理/主管": 5509, "渠道/分销经理": 5486, "资料员": 5478, "汽车销售/经纪人": 5416,
                      "物业管理专员/助理": 5411, "采购主管": 5401, "医药技术研发人员": 5399, "销售行政助理": 5378, "算法工程师": 5365, "物业管理主管": 5334,
                      "促销员/导购员": 5258, "课程顾问": 5255, "财务专员": 5150, "测试工程师": 5140, "预结算员": 5132, "咨询热线/呼叫中心服务人员": 5121,
                      "客户代表": 5117, "贸易/外贸经理/主管": 5014, "培训生": 5010, "采购助理": 4956, "大客户管理": 4942, "软件测试工程师": 4931,
                      "机电工程师": 4908, "售后服务/客户服务": 4830, "市场/营销/拓展总监": 4789, "结构/土木/土建工程师": 4781, "招聘经理/主管": 4739,
                      "生产文员": 4731, "机修工": 4728, "工程/机械绘图员": 4683, "钳工": 4673, "知识产权/专利/商标": 4612, "项目经理/主管": 4604,
                      "ERP实施顾问": 4594, "高级软件工程师": 4559, "餐饮服务员": 4553, "会计经理/会计主管": 4471, "科研人员": 4467,
                      "自动控制工程师/技术员": 4422, "项目工程师": 4409, "培训讲师": 4406, "美工/电商设计师": 4372, "法务主管/专员": 4359, "采购经理": 4246,
                      "中餐厨师": 4244, "跨境电商运营": 4232, "医药学术推广": 4207, "餐饮店长/经理": 4203, "市场/营销/拓展主管": 4193,
                      "FAE 现场应用工程师": 4177, "给排水/暖通工程": 4167, "商务经理": 4144, "保洁": 4138, "工业工程师": 4117, "客户经理/主管": 4106,
                      "数据分析师": 4064, "HRBP": 3961, "供应商管理": 3929, "焊工": 3912, "经理助理/秘书": 3889, "医药销售经理/主管": 3862,
                      "网店客服": 3856, "模具工程师": 3848, "人事助理": 3831, "客服主管": 3818, "集成电路IC设计/应用工程师": 3768, "主播/主持人": 3764,
                      "技术研发经理/主管": 3751, "环保工程师": 3743, "建筑安装施工员": 3708, "海外销售": 3694, "快递员": 3688, "直播运营": 3646,
                      "总监/部门经理": 3640, "城市经理": 3633, "叉车司机/铲车司机": 3614, "会计助理": 3604, "医疗器械销售经理/主管": 3593,
                      "物业维修员": 3550, "副总经理/副总裁": 3484, "摄影师/摄像师": 3469, "汽车修理工": 3449, "医药招商": 3429,
                      "医疗器械生产/质量管理": 3407, "审计专员/助理": 3407, "外贸销售": 3369, "装配工程师/技师": 3310, "电子技术研发工程师": 3305,
                      "项目执行/协调人员": 3298, "系统工程师": 3285, "运营经理": 3284, "仓储理货员": 3280, "环境/健康/安全经理/主管（EHS）": 3265,
                      "供应商开发": 3263, "咖啡师": 3257, "医学检验": 3243, "医疗器械研发": 3235, "智能大厦/综合布线/安防/弱电": 3234, "材料工程师": 3219,
                      "电力工程师/技术员": 3219, "销售行政专员": 3148, "产品专员": 3147, "组装工": 3142, "工厂经理/厂长": 3137, "工程监理": 3120,
                      "建筑工程师": 3069, "半导体技术": 3056, "电子/电器维修工程师/技师": 3056, "金融产品销售": 3048, "区域销售总监": 3041, "视频剪辑": 3037,
                      "售前/售后技术支持经理": 3027, "审计经理/主管": 3019, "电子软件开发(ARM/MCU...)": 3018, "财务总监": 3012, "电商经理/电商主管": 2995,
                      "船务/空运陆运操作": 2995, "网络推广专员": 2987, "硬件测试工程师": 2976, "技术文员/助理": 2955, "汽车设计工程师": 2866,
                      "医药技术研发管理人员": 2847, "半导体工艺工程师": 2846, "带货主播": 2845, "工程/设备经理": 2828, "技术总监/经理": 2816, "幼教": 2802,
                      "化学分析测试员": 2794, "包装工": 2788, "模具工": 2785, "数控编程": 2769, "市场企划专员": 2767, "产品/品牌经理": 2696,
                      "CNC工程师": 2692, "市场企划经理/主管": 2690, ".NET开发工程师": 2677, "Android开发工程师": 2663, "通信技术工程师": 2655,
                      "服装/纺织设计": 2651, "培训经理/主管": 2630, "水处理工程师": 2585, "编辑": 2554, "高级硬件工程师": 2526, "网络主播": 2505,
                      "测绘/测量": 2500, "市场助理": 2498, "建筑机电工程师": 2493, "市场分析/调研人员": 2480, "成本经理/成本主管": 2472, "直播销售": 2472,
                      "分拣员": 2471, "电商专员": 2465, "建筑设计师": 2460, "成本管理员": 2446, "消防安全": 2445, "工程/设备主管": 2443,
                      "培训专员/助理/培训师": 2433, "物流经理": 2428, "网络安全工程师": 2421, "项目助理": 2420, "人事总监": 2418, "讲师/助教": 2414,
                      "促销主管/督导/巡店": 2398, "仓库文员": 2397, "网站运营专员": 2380, "物流主管": 2371, "服装/纺织/皮革跟单": 2361,
                      "医疗器械市场推广": 2350, "活动策划": 2346, "注塑工程师/技师": 2337, "首席执行官CEO/总裁/总经理": 2330, "产品/品牌专员": 2315,
                      "房地产销售经理/主管": 2290, "客服经理": 2287, "食品/饮料研发": 2283, "招投标管理": 2263, "医疗器械注册": 2256, "运营主管": 2255,
                      "渠道/分销主管": 2242, "嵌入式硬件开发(主板机…)": 2230, "订单处理员": 2213, "运营助理": 2205, "英语老师": 2203,
                      "IT经理/IT主管": 2190, "院校教务管理人员": 2188, "动画/3D设计": 2172, "风险管理/控制": 2172, "空调/热能工程师": 2168,
                      "美容师": 2165, "后期制作": 2158, "品牌/连锁招商管理": 2113, "美容顾问": 2102, "园艺/园林/景观设计": 2096,
                      "高级客户经理/客户经理": 2091, "网络管理(Helpdesk)": 2083, "物料主管/专员": 2080, "设备主管": 2077, "职业技术教师": 2046,
                      "服装纺织质检员(QA/QC)": 2028, "公路/桥梁/港口/隧道工程": 2026, "营运经理": 2004, "律师/法律顾问": 1995, "收银员": 1982,
                      "激光/光电子技术": 1982, "环保检测": 1980, "催收": 1973, "规划与设计": 1967, "审核员": 1956, "电池/电源开发": 1953,
                      "系统架构设计师": 1952, "英语翻译": 1948, "C#开发工程师": 1947, "餐厅领班": 1938, "包装设计": 1924, "项目主管": 1917,
                      "运营总监": 1914, "车工": 1907, "单证员": 1903, "UI设计师": 1899, "保险内勤": 1894, "实验室负责人/工程师": 1863,
                      "区域销售主管": 1848, "证券/期货/外汇经纪人": 1847, "地推专员": 1846, "企业秘书/董事会秘书": 1817, "法务经理": 1812, "高中教师": 1809,
                      "电气/电器工程师": 1808, "售前/售后技术支持主管": 1795, "医疗器械维修人员": 1788, "PLC工程师": 1782, "理财顾问": 1780,
                      "保险经纪人/保险代理": 1778, "技术支持/维护经理": 1775, "日语翻译": 1772, "珠宝销售顾问": 1766, "焊接工程师/技师": 1750,
                      "供应链主管/专员": 1746, "内容运营": 1745, "大数据开发工程师": 1740, "呼叫中心客服": 1736, "临床研究员": 1734,
                      "企业文化/员工关系/工会管理": 1713, "房地产项目/策划主管/专员": 1712, "生产跟单": 1705, "模具设计": 1704, "需求工程师": 1696,
                      "行政主厨/厨师长": 1690, "业务分析专员/助理": 1684, "机器视觉工程师": 1681, "猎头/人才中介": 1673, "物业设施管理人员": 1662,
                      "初中教师": 1647, "用户运营": 1646, "报关与报检": 1642, "化验员": 1637, "营运主管": 1630, "房地产项目/策划经理": 1609,
                      "图像算法工程师": 1606, "射频工程师": 1601, "保险理赔": 1592, "临床协调员": 1591, "渠道/分销总监": 1590, "物业机电维修工": 1590,
                      "薪资福利专员/助理": 1587, "磨工": 1585, "临床监查员": 1581, "仪器/仪表/计量分析师": 1581, "导演/编导": 1578,
                      "办事处/分公司/分支机构经理": 1570, "调度员": 1559, "招生老师": 1557, "保险客户服务/续期管理": 1550, "生产总监": 1543,
                      "系统集成工程师": 1543, "切割技工": 1540, "学徒工": 1531, "医院管理人员": 1526, "搬运工": 1519, "FPGA开发工程师": 1517,
                      "酒店前台": 1501, "保险业务经理/主管": 1497, "网店店长": 1487, "展览/展示/店面设计": 1483, "小学教师": 1481, "助理业务跟单": 1475,
                      "数据库工程师(DBA)": 1474, "高级建筑工程师/总工": 1462, "ERP技术开发": 1450, "新能源电池工程师": 1439, "出租车司机": 1436,
                      "清洁工": 1435, "房地产项目招投标": 1434, "法务助理": 1431, "汽车质量工程师": 1430, "Python开发工程师": 1428, "风险控制": 1423,
                      "汽车项目管理": 1422, "PCB工程师": 1416, "视觉设计师": 1410, "奢侈品业务": 1406, "电子工艺工程师": 1406, "客户关系经理/主管": 1402,
                      "药库主任/药剂师": 1402, "咨询员": 1393, "统计员": 1393, "健身顾问/教练": 1386, "财务分析员": 1370, "产品规划工程师": 1360,
                      "保安经理": 1348, "党工团干事": 1347, "财务分析经理/主管": 1338, "金融产品经理": 1338, "仿真应用工程师": 1328, "汽车电子工程师": 1324,
                      "金融/经济研究员": 1322, "影视策划/制作人员": 1312, "半导体设备工程师": 1300, "厂务": 1287, "产品助理": 1284, "农业技术员": 1282,
                      "功能测试": 1257, "档案管理员": 1255, "酒店/宾馆经理": 1255, "标准化工程师": 1242, "药品注册": 1233, "电梯工": 1230,
                      "商品管理": 1228, "打样/制版": 1228, "铣工": 1227, "水利/水电工程师": 1222, "建筑制图/模型/渲染": 1219, "夹具工程师/技师": 1216,
                      "科研管理人员": 1212, "汽车钣金": 1204, "空调工": 1193, "市政工程师": 1190, "美术老师": 1190, "家具设计": 1189,
                      "社区/社群运营": 1180, "配菜/打荷": 1180, "药品市场推广经理": 1175, "理货员": 1174, "销售行政经理/主管": 1163, "化妆品研发": 1158,
                      "咨询经理": 1155, "产品/品牌主管": 1154, "建筑项目助理": 1153, "美容培训师/导师": 1152, "氩弧焊工": 1150, "品类管理": 1146,
                      "认证工程师": 1143, "数学老师": 1135, "物流销售": 1130, "保险电销": 1128, "光伏系统工程师": 1125, "汽车服务顾问": 1122,
                      "芯片销售工程师": 1117, "面点师": 1107, "家居设计": 1104, "测试开发": 1103, "IC验证工程师": 1095, "内科医生": 1093,
                      "礼仪/迎宾": 1091, "互联网产品经理": 1089, "模拟芯片工程师": 1083, "信贷管理": 1080, "暖通设计": 1075, "精装修工程师": 1073,
                      "税务专员/助理": 1071, "版图设计工程师": 1069, "环境影响评价工程师": 1069, "律师助理": 1063, "电子元器件工程师": 1061,
                      "内外饰工程师": 1031, "运维开发": 1031, "管道/暖通": 1025, "高级业务跟单": 1021, "自动化测试": 1014, "服装/纺织/皮革工艺师": 1013,
                      "供应链经理": 1010, "临床数据分析员": 1008, "汽车结构工程师": 1004, "PHP开发工程师": 1003, "薪资福利经理/主管": 1001,
                      "合规主管/专员": 997, "性能测试": 997, "机器人调试工程师": 995, "媒介专员": 992, "公关经理": 988, "绩效考核经理/主管": 984,
                      "班主任/辅导员": 977, "SMT工程师": 973, "校长": 970, "采购材料、设备质量管理": 968, "广告创意/设计主管/专员": 966,
                      "超声影像/放射科医师": 965, "项目总监": 964, "工艺整合工程师(PIE)": 956, "护理主任/护士长	955": 4, "S店经理/维修站经理": 953,
                      "税务经理/税务主管": 952, "理财顾问/财务规划师": 948, "店铺推广": 944, "数据运营": 943, "其他外语老师": 937, "药物合成/有机合成研究员": 937,
                      "活动执行": 927, "志愿者/社会工作者": 921, "房产项目配套工程师": 921, "有机合成研究员": 914, "建筑结构设计": 912, "厨师助理/学徒": 910,
                      "汽车喷漆": 909, "电路工程师/技术员(模拟/数字)": 900, "合同管理": 899, "产品总监": 896, "客房服务员/楼面服务员": 893, "语文老师": 889,
                      "给排水设计": 880, "客户质量工程师": 875, "综合门诊/全科医生": 871, "买手": 868, "公司业务客户经理": 867, "理疗师": 865,
                      "体育运动教练": 863, "石油天然气技术人员": 862, "选址拓展/新店开发": 858, "房地产内勤": 856, "试剂研发工程师": 856, "个人业务客户经理": 851,
                      "杂工": 851, "注塑工": 851, "药物分析研究员": 849, "计量工程师": 848, "餐饮大堂经理": 848, "药品市场推广主管/专员": 844,
                      "芯片测试工程师": 841, "验光师": 840, "信息流优化师": 837, "客运司机": 835, "材料员": 830, "信用卡销售": 828, "专科医生": 827,
                      "电脑操作员/打字员": 827, "牙科医生": 825, "建筑机电设计": 824, "半导体产品经理/产品工程师": 823, "绩效考核专员/助理": 823, "系统测试": 822,
                      "产品运营": 821, "企业策划人员": 816, "Unity3d开发工程师": 810, "无线通信工程师": 802, "政府事务管理": 801, "医美咨询": 798,
                      "国内贸易人员": 798, "钣金工": 798, "店长助理": 796, "移动开发工程师": 792, "房地产店长/经理": 789, "涂料研发工程师": 787,
                      "储备经理人": 785, "机构业务销售": 782, "二手车评估师": 781, "兼职": 781, "绿化工": 780, "装卸工": 779, "营业部总经理/副总经理": 777,
                      "财务顾问": 776, "面料辅料开发": 776, "焊接工艺工程师": 770, "制剂研究员": 769, "过程质量工程师": 769, "平面设计经理/主管": 767,
                      "汽车装配工艺工程师": 764, "房地产评估": 762, "茶艺师": 760, "兼职店员": 751, "铸造/锻造工程师/技师": 749, "采购总监": 748,
                      "房地产投资管理": 747, "维修经理/主管": 741, "专柜彩妆顾问(BA)": 740, "缝纫工": 739, "自动化运维工程师": 732, "乘务员": 730,
                      "数字前端工程师": 730, "电商总监": 730, "电子销售工程师": 727, "矿产勘探/地质勘测工程师": 726, "汽车装饰美容": 725, "内容审核": 721,
                      "网页设计师": 713, "日语老师": 712, "折弯工": 710, "网络推广经理/主管": 708, "美容店长": 708, "建筑工程验收": 706, "物理老师": 706,
                      "iOS开发工程师": 704, "房地产客服": 703, "西餐厨师": 691, "总工程师/副总工程师": 690, "餐饮收银员": 689, "漆工": 685,
                      "开发报建": 683, "网站运营经理/主管": 682, "留学顾问": 681, "洗碗工": 677, "培训督导": 672, "理财经理": 671, "兼职教师": 668,
                      "软装设计": 665, "HTML5开发工程师": 662, "可靠度工程师": 662, "家政服务/保姆": 662, "半导体测试工程师": 661, "全栈工程师": 660,
                      "电子设备工程师": 660, "行业研究员": 660, "地勤人员": 658, "体育教师": 653, "纸样师/车板工": 652, "城市规划设计": 649, "西点师": 649,
                      "车险定损/理赔": 648, "活动运营": 646, "公关专员": 643, "广告客户经理": 642, "失效分析工程师(FA)": 639, "物业机电工程师": 639,
                      "线下运营": 639, "通信项目管理": 639, "育婴师/保育员": 638, "股票/期货操盘手": 636, "清洁服务人员": 634, "ETL开发工程师": 633,
                      "韩语/朝鲜语翻译": 633, "外科医生": 632, "培训助理": 631, "通信网络工程师": 630, "游戏运营": 620, "证券分析师": 620, "冲压工": 619,
                      "团购经理/主管": 618, "资金专员": 617, "银行柜员": 615, "幕墙工程师": 613, "细胞培养技术员": 611, "会务/会展专员": 606,
                      "健康管理师": 602, "电子产品经理/产品工程师": 599, "音乐老师": 599, "研究生": 595, "行政总监": 595, "面料辅料采购": 595,
                      "VIP专员": 593, "娱乐服务员": 593, "BIM工程师": 592, "封装工程师": 588, "团购业务员": 584, "投诉专员": 584, "家装顾问": 583,
                      "中医科医生": 576, "仪表工": 575, "业务分析经理/主管": 568, "保险业务推动/督导": 563, "汽车试验工程师": 563, "岩土工程": 559,
                      "合伙人": 558, "抛光工": 555, "新能源电控工程师": 555, "农艺师": 552, "塑料工程师": 551, "底盘工程师": 551, "冲压工程师/技师": 546,
                      "电商产品经理": 546, "营养师": 546, "BI工程师": 543, "数据分析经理/主管": 543, "汽车电工": 540, "半导体器件工程师": 537,
                      "安检员": 536, "陈列员": 536, "汽车安全性能工程师": 535, "机器学习工程师": 532, "测试经理": 529, "营业部大堂经理": 528,
                      "钢结构设计": 525, "室内设计师助理": 523, "管家部经理/主管": 521, "锅炉工": 518, "涂装工艺工程师": 516, "网站编辑": 514,
                      "集装箱业务": 514, "运输经理/主管": 511, "导医": 509, "样衣工": 509, "研发总监/部长/专家": 507, "家教": 504, "管理咨询师": 504,
                      "针灸/推拿": 504, "图书管理员/资料管理员": 503, "工长": 502, "汽车检验/检测": 502, "数据采集工程师": 500, "幕墙设计": 498,
                      "飞行器设计与制造": 495, "光源与照明工程": 493, "培训产品开发": 492, "新能源电机工程师": 489, "印刷机械机长": 485, "船舶工程师": 485,
                      "前台迎宾": 484, "媒介经理": 484, "导游/旅行顾问": 481, "学习规划师": 480, "绘画": 479, "模拟版图工程师": 478, "数字后端工程师": 474,
                      "策略发展总监": 473, "资产评估/分析": 473, "西点师/面包糕点加工": 471, "封装研发工程师": 469, "专业培训师": 466, "证券交易员": 466,
                      "印刷工": 463, "GIS工程师": 461, "深度学习工程师": 461, "资金经理/主管": 456, "电声/音响工程师/技术员": 454, "安全测试": 453,
                      "调研员": 453, "供应链总监": 451, "调酒师/侍酒师/吧台员": 451, "经纪人/星探": 450, "经销商": 450, "Go开发工程师": 447,
                      "化学老师": 447, "咨询总监": 447, "车身/造型设计": 447, "药理研究员": 445, "多媒体开发工程师": 442, "生态治理/规划": 442,
                      "废气处理工程师": 441, "测试主管": 440, "早教老师": 438, "洗车工": 438, "网络维修": 438, "写字楼运营": 437, "互联网营销师": 433,
                      "舞蹈老师": 432, "信审核查": 428, "前期质量工程师": 426, "广告销售": 424, "综合业务专员": 424, "物流总监": 423, "电力线路工": 423,
                      "楼宇自动化": 422, "游戏策划师": 420, "场长(农/林/牧/渔业)": 417, "保险核保": 416, "动物实验技术员": 416, "数据仓库工程师": 415,
                      "教研组长/主管": 414, "媒介主管": 413, "电脑维修": 412, "主播助理": 411, "生鲜食品加工/处理": 407, "射频芯片设计": 406, "木工": 406,
                      "化妆师": 405, "特种车司机": 405, "微信运营": 401, "游戏测试": 401, "图像处理工程师": 400, "服装/纺织设计总监": 399,
                      "酒店/宾馆销售": 399, "会籍顾问": 392, "监察人员": 392, "用户体验（UE/UX）设计师": 391, "兽医": 387, "传菜员": 386,
                      "医学顾问": 386, "冲压工艺工程师": 385, "合规经理": 384, "印刷排版/制版": 383, "品类运营": 382, "酒店大堂经理": 382,
                      "动物营养/饲料研发": 379, "汽车/摩托车工程师": 375, "票务": 375, "广告客户主管/专员": 374, "配色技术员": 374, "锅炉工程师/技师": 374,
                      "广告制作执行": 373, "精装设计": 372, "饲养员": 371, "基金经理": 368, "模特": 364, "原画师": 363, "游戏开发工程师": 363,
                      "技术文档工程师": 362, "动力总成工程师": 359, "美甲师": 359, "旅游产品销售": 356, "用户产品经理": 355, "市场通路经理/主管": 353,
                      "数据建模工程师": 352, "班车司机": 352, "固定资产会计": 351, "智能驾驶工程师": 350, "游戏场景设计师": 348, "水质检测员": 347,
                      "情报信息分析人员": 346, "数据治理工程师": 344, "美容整形师": 344, "房地产投资分析": 343, "首席运营官COO": 343, "陈列管理": 342,
                      "家用电器/数码产品研发": 341, "园长": 339, "变压器与磁电工程师": 338, "业务跟单经理": 334, "喷塑工": 333, "畜牧师": 332,
                      "食品安全管理师": 331, "照明设计": 330, "广告创意/设计经理": 328, "代驾": 325, "其他语种翻译": 323, "发动机工程师": 323,
                      "数据通信工程师": 321, "房修工程师": 319, "通信测试工程师": 319, "培训策划": 317, "按摩": 317, "高级物业顾问/物业顾问": 315,
                      "数据标注师": 314, "油漆工": 314, "海关事务管理": 313, "钻工": 313, "停车管理员": 311, "期货分析师": 311, "工艺品/珠宝设计鉴定": 310,
                      "光通信工程师": 307, "多媒体设计": 304, "调饮师": 303, "房地产资产管理": 301, "会务/会展经理": 299, "排版设计": 299,
                      "长租公寓管家/养老专员": 297, "核酸检测员": 293, "游戏原画师": 292, "人力资源信息系统专员": 291, "公共卫生/疾病控制": 291,
                      "市场通路专员": 291, "系统分析员": 291, "行长/副行长": 291, "公关主管": 290, "芯片架构工程师": 289, "保险培训师": 288,
                      "教师培训/师训": 288, "汽车标定工程师": 286, "护工": 284, "安防主管": 283, "故障分析工程师": 281, "水工": 281, "配置管理工程师": 281,
                      "记者": 277, "客服总监": 276, "首席财务官 CFO": 276, "大学教授": 275, "特效设计师": 273, "心理咨询师": 271, "教研员": 270,
                      "量化研究": 268, "儿科医生": 267, "汽车金融销售": 266, "企业/业务发展经理": 264, "轨道交通工程师/技术员": 263, "救生员": 261,
                      "电子文档工程师": 261, "小微信贷专员": 260, "游戏角色设计师": 260, "有线传输工程师": 259, "媒介销售": 256, "SPA 技师": 252,
                      "日式厨师": 251, "MEMS工程师": 250, "UE4开发工程师": 249, "游戏界面设计师": 249, "交互设计师": 248, "导购管理": 248,
                      "室内设计经理/主管": 246, "寻呼员/话务员": 245, "病理研究员": 245, "自然语言处理(NLP)": 241, "拍卖/担保/典当业务": 240,
                      "法务总监": 240, "美术指导": 239, "陈列设计": 239, "眼科医生": 237, "铆工": 237, "小程序开发工程师": 236, "公司金融顾问": 235,
                      "楼面经理": 234, "公关/媒介助理": 232, "首席技术执行官CTO": 232, "宾客服务经理": 230, "安防系统工程师": 229, "月嫂": 229,
                      "空调维修": 229, "网站维护工程师": 228, "药物警戒专员": 226, "前介工程师": 225, "总装工程师": 225, "平面设计总监": 222, "编剧": 221,
                      "通信电源工程师": 221, "游戏特效设计师": 220, "劳务派遣专员": 219, "玩具设计": 217, "养殖部主管": 216, "防损员/内保": 216,
                      "试剂研发经理": 213, "车联网工程师": 213, "广告客户总监/副总监": 212, "汽车金融专员": 211, "船员": 211, "瑜伽老师": 210,
                      "行程管理/计调": 207, "裁剪工": 207, "可测性设计工程师(DFT)": 206, "物料经理": 203, "钢琴老师": 202, "驻唱/歌手": 200,
                      "西班牙语翻译": 193, "美容助理": 192, "服装领班": 191, "游泳教练": 191, "网店模特": 191, "美体师": 191, "俄语翻译": 190,
                      "德语翻译": 188, "综合业务经理/主管": 188, "收货员": 187, "网店店铺管理员": 186, "加油站工作员": 185, "演员/群众演员": 184,
                      "游戏动作设计师": 180, "家电维修": 179, "出版/发行": 177, "手机维修": 177, "固废工程师": 176, "客户主管/专员": 175,
                      "通信产品经理/产品工程师": 173, "EDA工程师": 172, "会务/会展主管": 172, "图像识别工程师": 172, "通信设备工程师": 172, "广告创意总监": 169,
                      "舞蹈演员": 166, "公司业务部门经理/主管": 165, "游戏动画师": 165, "校对/录入": 164, "法语翻译": 164, "吊车司机": 163,
                      "宴会管理": 163, "镗工": 162, "智能驾驶测试工程师": 160, "网站策划": 160, "电镀工": 157, "行李员": 157, "公关总监": 156,
                      "站务人员": 156, "宠物护理/美容": 152, "室内设计总监": 151, "区块链开发": 150, "预订员": 150, "游戏服务端开发工程师": 149,
                      "游戏数值策划": 148, "美术编辑": 147, "足疗": 147, "艺术/设计总监": 146, "网站运营总监": 145, "收银主管": 144, "游戏系统策划": 144,
                      "保险产品开发/项目策划": 143, "附件系统工程师": 141, "作家/撰稿人": 140, "发型师": 140, "通信销售工程师": 140, "智能硬件装调员": 138,
                      "灯光师": 138, "药物警戒经理": 137, "裁床": 135, "麻醉医生": 135, "个人业务部门经理/主管": 133, "婚礼/庆典策划服务": 133,
                      "二手车经纪人": 130, "清算人员": 130, "烫工": 130, "移动端测试": 130, "游戏客户端开发工程师": 128, "爬虫开发工程师": 125,
                      "妇产科医生": 123, "FPGA原型验证工程师": 122, "发型助理/学徒": 118, "计算机辅助设计工程师": 118, "UE4特效师": 117, "外汇交易": 116,
                      "板房/楦头/底格出格师": 115, "洗衣工": 115, "电脑放码员": 114, "网络推广总监": 114, "旅游策划师": 113, "保险精算师": 112,
                      "移动产品经理": 112, "碳排放管理员": 111, "核心网工程师": 109, "总编/副总编": 108, "促销经理": 107, "调色员": 99, "音效师": 99,
                      "工业视觉系统运维员": 98, "彩妆培训师": 98, "进出口/信用证结算": 98, "驾校教练": 97, "飞机维修机械师": 96, "在线辅导老师": 95,
                      "基站工程师": 95, "语音识别工程师": 94, "艺术指导/舞台美术设计": 92, "健身房服务": 91, "中专/职校生": 89, "娱乐领班": 89,
                      "服务机器人应用技术员": 89, "心理医生": 87, "混凝土工": 87, "游戏文案策划/剧情策划": 87, "造纸研发": 86, "船长/副船长": 85,
                      "办事处首席代表": 84, "制片人": 82, "切纸机操作工": 80, "脚本开发工程师": 80, "装订工": 80, "泰语翻译": 78, "Flash设计师": 77,
                      "消毒员": 77, "汽车金融经理": 76, "研学项目主管/经理": 76, "公务员": 75, "造型师": 74, "瓦工": 73, "钟点工": 73, "葡萄牙语翻译": 72,
                      "Cocos2d-x开发工程师": 69, "印染工": 69, "手缝工": 68, "城市管理网格员": 67, "推荐算法工程师	67": 3, "D打印操作员": 63,
                      "纺织工": 63, "高尔夫教练": 63, "熟食加工": 62, "首席信息官CIO": 62, "施工开料工": 60, "数码直印/菲林输出": 59, "吹膜工": 58,
                      "阿拉伯语翻译": 58, "Hadoop工程师": 57, "送水工": 57, "挖掘机司机": 55, "保镖": 53, "半导体文档工程师": 50, "司仪": 48,
                      "空乘人员": 48, "契约管理": 46, "游戏关卡策划": 45, "烫金工": 43, "挡车工": 42, "配色工": 42, "传菜主管": 39, "钢筋工": 39,
                      "测试总监": 38, "银行客户总监": 38, "瘦身顾问": 36, "砌筑工": 35, "签证专员": 35, "网站架构设计师": 35, "调墨技师": 35,
                      "餐饮预订员": 35, "发动机匹配工程师": 34, "放映员": 33, "电子竞技运营": 33, "美发店长": 33, "预订主管": 33, "意大利语翻译": 32,
                      "硫化工": 32, "驯兽师/助理驯兽师": 32, "配音员": 31, "搜索算法工程师": 30, "微博运营": 29, "晒版员": 28, "通信文档工程师": 28,
                      "企业贸易合规师": 26, "放映经理/主管": 26, "Ruby开发工程师": 25, "酒体设计师": 24, "密码技术应用员": 23, "针织工": 21, "防疫员": 21,
                      "压痕工": 20, "飞机机长/副机长": 20, "抹灰工": 19, "炼胶工": 18, "电话采编": 18, "汽车救援员": 17, "刨工": 16,
                      "电子数据取证分析师": 16, "音效设计师": 16, "漂染工": 14, "DJ": 13, "机场代表": 13, "复卷工": 11, "裱胶工": 11,
                      "列车/地铁司机": 10, "中国方言翻译": 9, "浇注工": 9, "电分操作员": 9, "电信交换工程师": 8, "打稿机操作员": 5, "整经工": 5, "旋压工": 4,
                      "细纱工": 2, "列车/地铁车长": 1, }


class Parse:
    def __init__(self):
        self.pattern = re.compile(r'(\d+\.*\d*).*?')
        self.company_state_mapping = {'存续': 0, '在业': 1, '吊销': 2, '注销': 3, '迁入': 4, '迁出': 5, '停业': 6, '清算': 7, 8: '其他'}
        self.manage_state = ['存续', '在业', '吊销', '注销', '迁入', '迁出', '停业', '清算']
        self.education = ['初中', '高中', '中专', '中技', '大专', '本科', '硕士', '博士', 'MBA', 'EMBA', '其他']
        self.education_mapping = {'不限': 0, '初中': 1, '高中': 2, '中专': 3, '中技': 3, '大专': 4, '本科': 5, '硕士': 6, '博士': 7,
                                  'MBA': 8, 'EMBA': 8, '其他': 9}

    def parse_work_experience(self, work_experience):
        """
        获取工作经验中的年限，格式化返回
        @param work_experience:
        @return: 工作经验对应的数字
        0: "不限", 1: "无经验", 2: "1年以内", 3: "1-3年", 4: "3-5年", 5: "5-10年", 6: "10年以上", 7:"在校/应届"
        """
        if work_experience == '无经验':
            return 1
        elif work_experience == '不限':
            return 0
        elif '在校' in work_experience or '应届' in work_experience:
            return 7
        work_years = self.pattern.findall(work_experience)
        work_years = [eval(x) for x in work_years if x]
        if len(work_years):
            work_year = max(work_years)
            if work_year <= 1:
                return 2
            elif work_year <= 3:
                return 3
            elif work_year <= 5:
                return 4
            elif (work_year <= 10) and ('以上' not in work_experience):
                return 5
            elif (work_year == 10 and '以上' in work_experience) or (work_year > 10):
                return 6
            else:
                return 0
        else:
            return 0

    def parse_education(self, education):
        """
        根据学位返回学位对应的序号
        @param education: 学位 string
        @return: 学历
        0: "不限", 1: "初中及以下", 2: "高中", 3: "中专/中技", 4: "大专", 5: "本科", 6: "硕士", 7: "博士", 8: "MBA/EMBA", 9: "其他"
        """
        for key in self.education:
            if key in education:
                return self.education_mapping.get(key, 0)
        return 0

    def parse_company_person_num(self, person_number):
        """
        获取公司人数，并对数量进行分类处理
        @param person_number:
        @return: 工作经验对应的数字
        0: 不限, 1: 0-20人, 2: 20-99人, 3: 100-499人, 4: 500-999人, 5: 1000-9999', 6: 10000人以上
        """
        if person_number:
            number_ls = self.pattern.findall(str(person_number))
            number_ls = [eval(x) for x in number_ls if x]
            if len(number_ls):
                person_number = max(number_ls)
                if person_number <= 20:
                    return 1
                elif person_number <= 99:
                    return 2
                elif person_number <= 499:
                    return 3
                elif person_number <= 999:
                    return 4
                elif person_number <= 9999:
                    return 5
                elif person_number > 9999:
                    return 6
            else:
                return 0
        else:
            return 0

    def parse_recruit_num(self, recruit_num):
        """
        从招收人数的字符串中获取招收人数
        @param recruit_num: 招收人数字符串
        @return: 工作经验对应的数字
        """
        number_ls = self.pattern.findall(recruit_num)
        number_ls = [eval(x) for x in number_ls if x]
        if len(number_ls):
            return max(number_ls)
        else:
            return 1

    def parse_salary(self, salary):
        """
        将薪资返回处理成最高薪资，最低薪资，多少薪
        @param salary: 薪资范围字符串
        @return: [最低薪资， 最高薪资， 多少薪]
        """
        if '面议' in salary:
            return [0, 0, 12]
        try:
            salary_list = self.pattern.findall(salary)
            salary_list = [eval(x) for x in salary_list]
            salary_len = len(salary_list)
            if not salary_len:
                return [0, 0, 12]
        except BaseException as e:
            print('Salary parse error:', e)
            return [0, 0, 12]
        if len(salary_list) == 1:
            unit = self.change_unit(salary)
            return self.calculate_salary(salary, salary_list[0], salary_list[0], unit, unit, 12)
        elif len(salary_list) == 2:
            if '薪' in salary and '月薪' not in salary and '年薪' not in salary:
                unit = self.change_unit(salary)
                return self.calculate_salary(salary, salary_list[0], salary_list[0], unit, unit, salary_list[1])
            else:
                s0 = str(salary_list[0]).replace('.', r'\.')
                s1 = str(salary_list[1]).replace('.', r'\.')
                unit_1 = self.change_unit(
                    re.search(r'%s(\S+?)\s?' % s0, salary).group(1))
                try:
                    if salary_list[1] == salary_list[0]:
                        unit_2 = self.change_unit(re.search(r'.*%s(\S+?)' % s1, salary).group(1))
                    else:
                        unit_2 = self.change_unit(
                            re.search(r'%s(\S+?)' % s1, salary.replace(str(salary_list[0]), '', 1)).group(1))
                except AttributeError as e:
                    print(e)
                    unit_2 = 1
                return self.calculate_salary(salary, salary_list[0], salary_list[1], unit_1, unit_2, 12)
        elif len(salary_list) == 3:
            s0 = str(salary_list[0]).replace('.', r'\.')
            s1 = str(salary_list[1]).replace('.', r'\.')
            unit_1 = self.change_unit(
                re.search(r'%s(\S+?)\s?' % s0, salary).group(1))
            if salary_list[1] == salary_list[0]:
                unit_2 = self.change_unit(re.search(r'%s.*?%s(\S+?)\s?' % (s0, s1), salary).group(1))
            else:
                unit_2 = self.change_unit(
                    re.search(r'%s(\S+?)' % s1, salary.replace(str(salary_list[0]), '', 1)).group(1))
            return self.calculate_salary(salary, salary_list[0], salary_list[1], unit_1, unit_2, salary_list[2])
        else:
            return [0, 0, 12]

    def change_unit(self, unit_value):
        """
        转换单位为数字
        :param unit_value:
        :return: unit (int)
        """
        if 'k' in unit_value or 'K' in unit_value or '千' in unit_value:
            return 1000
        elif '百万' in unit_value or '百萬' in unit_value:
            return 1000000
        elif '百' in unit_value:
            return 100
        elif '万' in unit_value or '萬' in unit_value:
            return 10000
        else:
            return 1

    def calculate_salary(self, salary, minSalary, maxSalary, unit_min, unit_max, much_salary):
        """
        计算薪资
        :param salary: 薪资文本
        :param minSalary: 最小薪资
        :param maxSalary: 最大薪资
        :param unit_min: 最小薪资单位
        :param unit_max: 最大薪资单位
        :param much_salary:薪资月数
        :return: [最低薪资， 最高薪资， 多少薪]
        """
        if unit_min == 1 and minSalary <= maxSalary:
            unit_min = unit_max
        if '天' in salary:
            return [minSalary * unit_min * 21.75, maxSalary * unit_max * 21.75, much_salary]
        elif '周' in salary:
            return [minSalary * unit_min * 4, maxSalary * unit_max * 4, much_salary]
        elif '年' in salary:
            return [minSalary * unit_min // 12, maxSalary * unit_max // 12, much_salary]
        elif '时' in salary or '時' in salary:
            return [minSalary * unit_min * 174, maxSalary * unit_max * 174, much_salary]
        else:
            return [minSalary * unit_min, maxSalary * unit_max, much_salary]

    def parse_manage_state(self, state):
        """
        格式化处理公司用运行的状态
        @param state: 公司运行的状态
        @return:
        """
        for key in self.manage_state:
            if key == '存续':
                list1 = [key, "开业", "正常", "登记"]
                if len([x for x in list1 if x in state]):
                    return self.company_state_mapping.get(key)
            if key == "在业":
                list1 = [key, "在营", "正常", "经营", "在营在册", "有效", "在业在册"]
                if len([x for x in list1 if x in state]):
                    return self.company_state_mapping.get(key)
            if key in state:
                return self.company_state_mapping.get(key)
        return 8

    def parse_date(self, publishdate, default=datetime.date.today()):
        # if not publishdate:
        #     return default
        # today = datetime.date.today()
        # if '小时前' in publishdate or '分钟前' in publishdate:
        #     return today
        # elif '天前' in publishdate:
        #     d_day = re.search(r'(\d+)天前', publishdate).group(1)
        #     return today - datetime.timedelta(days=int(d_day))
        # elif '年' in publishdate and '月' in publishdate and '日' in publishdate:
        #     d = re.search(r'(\d+)年(\d+)月(\d+)日', publishdate)
        #     if len(d.group(1)) == 2:
        #         return datetime.date(year=int('20' + d.group(1)), month=int(d.group(2)), day=int(d.group(3)))
        #     elif len(d.group(1)) == 4:
        #         return datetime.date(year=int(d.group(1)), month=int(d.group(2)), day=int(d.group(3)))
        #     else:
        #         return datetime.date(year=today.year, month=int(d.group(2)), day=int(d.group(3)))
        # elif '月' in publishdate and '日' in publishdate:
        #     d = re.search(r'(\d+)月(\d+)日', publishdate)
        #     return datetime.date(year=today.year, month=int(d.group(1)), day=int(d.group(2)))
        # elif '-' in publishdate or '/' in publishdate:
        #     if '-' in publishdate:
        #         date_list = publishdate.split('-')
        #     else:
        #         date_list = publishdate.split('/')
        #     if len(date_list) == 2:
        #         return datetime.date(today.year, int(date_list[0]), int(date_list[1]))
        #     elif len(date_list) == 3:
        #         if len(date_list[0]) == 2:
        #             y = int('20' + date_list[0])
        #         elif len(date_list[0]) == 4:
        #             y = int(date_list[0])
        #         else:
        #             y = today.year
        #         return datetime.date(y, int(date_list[1]), int(date_list[2]))
        #     else:
        #         return today
        # else:
        #     return default
        return datetime.datetime.strptime(publishdate, '%Y-%m-%d %H:%M:%S')

    def last_date(self, update_time):
        if update_time.month == 1:
            return update_time.year - 1, 12
        else:
            return update_time.year, update_time.month - 1


class SqlQueue:  # mysql长连接类
    def __init__(self, host="localhost", user="root", password="123456", database="pa1"):
        """
        初次链接，存放链接属性
        :param host: 数据库ip地址
        :param user: 用户名
        :param password: 密码
        :param database: 数据库名称
        """
        self.host = host
        self.user = user
        self.password = password
        self.database = database
        self.charset = 'utf8'
        self.q = Queue(maxsize=10)
        for i in range(0, 10):
            db = pymysql.connect(host=host, user=user, password=password, database=database,
                                 charset='utf8')  # 打开数据库连接
            self.q.put(db)

    def test_conn(self, db):
        """
        测试是否断开链接，并重连
        """
        # noinspection PyBroadException
        try:
            db.ping()  # 运行ping函数，判断是否断开链接
            return True
        except BaseException:
            return False

    def select(self, sql, fetch_one=False):
        """
        查询模块
        :param sql: 查询语句
        :param is_pd: 是否以pandas结果输出
        :return: sql查询结果
        """
        results = None
        while True:
            db = self.q.get()
            if db:
                break
            else:
                time.sleep(1)
        if not self.test_conn(db):
            db = pymysql.connect(host=self.host, user=self.user, password=self.password,
                                 database=self.database, charset=self.charset)  # 重连数据库
        cursor = db.cursor(pymysql.cursors.DictCursor)  # 使用cursor()方法获取操作游标
        try:
            cursor.execute(sql)  # 执行SQL语句
            if fetch_one:
                results = cursor.fetchone()
            else:
                results = cursor.fetchall()  # 获取所有记录列表
            # print('查询成功')
        except BaseException as e:
            print("Error: unable to fetch data", e)
        finally:
            self.q.put(db)
        return results

    def update(self, sql, data=None):
        """
        更新
        :param sql: 更新语句
        :param data: 更新的参数列表
        """
        while True:
            db = self.q.get()
            if db:
                break
            else:
                time.sleep(1)
        if not self.test_conn(db):
            db = pymysql.connect(host=self.host, user=self.user, password=self.password,
                                 database=self.database, charset=self.charset)  # 重连数据库
        cursor = db.cursor(pymysql.cursors.DictCursor)  # 使用cursor()方法获取操作游标
        try:
            if data:
                cursor.execute(sql, data)  # 执行SQL语句
            else:
                cursor.execute(sql)  # 执行SQL语句
            db.commit()  # 提交到数据库执行
            # print('更新成功')
        except BaseException as e:
            print('Error: ', e)
            db.rollback()  # 发生错误时回滚
        finally:
            self.q.put(db)

    def insert(self, sql, data=None):
        """
        新增
        :param sql:插入语句
        :param data: 插入的数据列表
        :return: 最新id
        """
        while True:
            db = self.q.get()
            if db:
                break
            else:
                time.sleep(1)
        if not self.test_conn(db):
            db = pymysql.connect(host=self.host, user=self.user, password=self.password,
                                 database=self.database, charset=self.charset)  # 重连数据库
        cursor = db.cursor(pymysql.cursors.DictCursor)  # 使用cursor()方法获取操作游标
        try:
            if data:
                cursor.execute(sql, data)  # 执行SQL语句
            else:
                cursor.execute(sql)  # 执行SQL语句
            db.commit()  # 提交到数据库执行
            # print('插入成功')
            return cursor.lastrowid
        except BaseException as e:
            print('Error: ', e)
            db.rollback()  # 发生错误时回滚
        finally:
            self.q.put(db)

    def delete(self, sql):
        """
        删除
        :param sql: 删除语句
        """
        while True:
            db = self.q.get()
            if db:
                break
            else:
                time.sleep(1)
        if not self.test_conn(db):
            db = pymysql.connect(host=self.host, user=self.user, password=self.password,
                                 database=self.database, charset=self.charset)  # 重连数据库
        cursor = db.cursor(pymysql.cursors.DictCursor)  # 使用cursor()方法获取操作游标
        try:
            cursor.execute(sql)  # 执行SQL语句
            db.commit()  # 提交到数据库执行
            # print('删除成功')
        except BaseException as e:
            print('Error: ', e)
            db.rollback()  # 发生错误时回滚
        finally:
            self.q.put(db)

    def __del__(self):
        """
        断开数据库链接
        """
        try:
            while True:
                self.q.get().close()
                if self.q.empty():
                    break
        except BaseException as e:
            print(e)


class Spider:
    def __init__(self):
        self.spider_name = str(__file__.split('\\')[-1])
        self.client = redis.Redis('10.86.0.107', decode_responses=True)
        self.headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36",
            'referer': 'https://www.51job.com/',
        }
        self.p = Parse()
        self.sql = SqlQueue(host='10.86.0.107', user='root', password='wit123456', database='hrdatabase')
        self.sql_company_id = "SELECT" + " id FROM company.company_info WHERE companyUrl = '%s' OR companyName = '%s' "
        self.sql_company = "INSERT" + """ INTO company.company_info (companyName,companyUrl,companyType,companyPersonNum,companyIndustry,`status` ,update_time)
                VALUES (%s,%s,%s,%s,%s,%s,%s);"""
        self.sql_update = "UPDATE" + """ jobinfo_list SET is_used = MONTH(CURDATE()) ,update_time = %s WHERE id = %s """
        # with open('js51.js', "r", encoding='utf8') as f:
        #     js = f.read()
        # self.v1 = execjs.compile(js)
        # self.v2 = execjs.compile(js2)
        self.list_url = "https://cupidjob.51job.com/open/noauth/search-pc"
        self.failed_proxies = set()
        self.proxies = []
        self.thread_proxy_map = {}
        threading.Thread(target=self.get_proxies, daemon=True).start()

        self.url_set = set()
        self.m = str(datetime.date.today().month).zfill(2)

    def get_proxy(self):
        while True:
            if self.proxies:
                return random.choice(self.proxies)
            else:
                print('未获取到代理ip,重试中...')
            time.sleep(2)
    def get_proxies(self):
        while True:
            try:
                self.proxies = self.client.lrange('use_proxies', 0, -1)
                self.failed_proxies = set(self.proxies) & self.failed_proxies
                self.proxies = [x for x in self.proxies if x not in self.failed_proxies]
            except Exception as e:
                if isinstance(e, KeyboardInterrupt):
                    raise KeyboardInterrupt(e)
                print(e)
            time.sleep(1)
    def add_failed_proxy(self, proxy):
        if proxy not in self.failed_proxies:
            self.failed_proxies.add(proxy)
            self.proxies = [x for x in self.proxies if x not in self.failed_proxies]

    def download(self, url, page=1, timesleep=0.5, timeout=5, ii=3, url_item: dict = None):
        thread_name = threading.currentThread().getName().replace('-', '')
        thead_map = self.thread_proxy_map.get(thread_name, {})
        proxy = thead_map.get('proxy', self.get_proxy())
        cookies = thead_map.get('cookie', {}) or {}
        print('Downloading: %s' % url)
        proxies = {'http': 'http://%s' % proxy, 'https': 'http://%s' % proxy}
        params = {
            "api_key": "51job",
            "timestamp": str(int(time.time())),
            "keyword": "",
            "searchType": "2",
            "function": url_item['url'].split('$')[-1],
            "industry": "",
            "jobArea": url_item['url'].split('$')[0],
            "jobArea2": "",
            "landmark": "",
            "metro": "",
            "salary": "",
            "workYear": "",
            "degree": "",
            "companyType": "",
            "companySize": "",
            "jobType": "",
            "issueDate": "3",
            "sortType": "1",
            "pageNum": page,
            "requestId": "",
            "pageSize": "100",
            "source": "1",
            "accountId": "",
            "pageCode": "sou|sou|soulb"
        }
        headers = {
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
            "Connection": "keep-alive",
            "From-Domain": "51job_web",
            "Origin": "https://we.51job.com",
            "Referer": "https://we.51job.com/",
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-site",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36",
            "account-id": "",
            "partner": "",
            # "property": "%7B%22partner%22%3A%22%22%2C%22webId%22%3A2%2C%22fromdomain%22%3A%2251job_web%22%2C%22frompageUrl%22%3A%22https%3A%2F%2Fwe.51job.com%2F%22%2C%22pageUrl%22%3A%22https%3A%2F%2Fwe.51job.com%2Fpc%2Fsearch%3FjobArea%3D030300%26function%3D2711%26issueDate%3D3%26keyword%3D%26searchType%3D2%26sortType%3D1%26metro%3D%22%2C%22identityType%22%3A%22%22%2C%22userType%22%3A%22%22%2C%22isLogin%22%3A%22%E5%90%A6%22%2C%22accountid%22%3A%22%22%7D",
            "sec-ch-ua": "\"Not?A_Brand\";v=\"8\", \"Chromium\";v=\"108\", \"Google Chrome\";v=\"108\"",
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": "\"Windows\"",
            "sign": self.hmac_md5('abfc8f9dcf8c3f3d8aa294ac5f2cf2cc7767e5592590f39c3f503271dd68562b',
                                  "/open/noauth/search-pc?" + parse.urlencode(params)),
            "user-token": "",
            "uuid": uuid4().hex
        }
        try:
            response = requests.get(self.list_url, params=params, headers=headers, proxies=proxies, timeout=timeout,
                                    cookies=cookies)
        except BaseException as e:
            print('error :', e)
            self.add_failed_proxy(proxy)
            self.thread_proxy_map[thread_name] = {'proxy': self.get_proxy(), 'cookie': None}
            time.sleep(timesleep)
            return self.download(url=url, ii=ii - 1, url_item=url_item, page=page)
        time.sleep(timesleep)
        # try:
        try:
            response.json()['message'] == '成功'
            cookies.update(response.cookies.get_dict())
            self.thread_proxy_map[thread_name] = {'proxy': proxy, 'cookie': cookies}
            return response
        except Exception as e:
            cookies.update(response.cookies.get_dict())
            if ii > 1:
                time.sleep(timesleep)
                self.thread_proxy_map[thread_name] = {'proxy': proxy, 'cookie': cookies}
                return self.download(url=url, ii=ii - 1, page=page, url_item=url_item)
            else:
                return False
            print(e)

    def hmac_md5(self, key, msg):
        """
        Create a new hashing object and return it.
        :param key: The starting key for the hash.
        :param msg: if available, will immediately be hashed into the object's starting
    state.
        :return: 加密后的结果 str
        """
        return hmac.new(key.encode('utf-8'), msg.encode('utf-8'), 'sha256').hexdigest()

    def get_list(self, url_items):
        # origin_url = url_items['url']
        origin_url = "020000&0121"
        response = self.download(origin_url, url_item=url_items)
        # 考虑是因为网络原因导致，返回True后面页面可以继续采集
        if response is None:
            print('无响应')
            return True
        try:
            html_json = response.json()['resultbody']

            data_list = html_json['job']['items']
            total_page = math.ceil(html_json['job']['totalcount'] / 100)
        except BaseException as e:
            print(e)
            data_list = []
            total_page = 1
        if total_page > 500:
            total_page = 500
        print('total_page:', total_page)

        if self.get_item_to_sql(data_list, url_items):
            for i in range(2, total_page + 1):
                if not self.get_next(origin_url, url_items=url_items, page=i):
                    break

    def get_next(self, next_url, url_items, page=2):
        response = self.download(next_url, page=page, url_item=url_items)
        # 考虑是因为网络原因导致，返回True后面页面可以继续采集
        if response is None:
            return True

        try:
            html_json = response.json()['resultbody']
            data_list = html_json['job']['items']
        except BaseException:
            data_list = []

        if len(data_list) > 0:
            return self.get_item_to_sql(data_list, url_items)

    def get_item_to_sql(self, data_list, url_items):
        print('data_list:', len(data_list))
        qc_number = 0
        for data in data_list:
            item = url_items.copy()
            item['update_time'] = datetime.datetime.now()  # 发布日期
            p_y, p_m = self.p.last_date(item['update_time'])
            try:
                item['publishTime'] = self.p.parse_date(
                    str(data.get('issueDateString', time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))[:19]))  # 插入时间
                if item['publishTime'] < datetime.datetime(year=p_y, month=p_m, day=1, minute=0, hour=0):
                    continue
            except AttributeError:
                continue
            item['detailUrl'] = data.get('jobHref', "")  # 职位详情地址
            if self.url_qc(item['detailUrl']):
                qc_number += 1
                continue
            item['jobName'] = data.get('jobName', '')  # 职位名称
            item['companyName'] = data.get('companyName', "")  # 公司名称
            item['companyPersonNum'] = self.p.parse_company_person_num(data.get('companySizeString', ""))  # 公司规模
            item['companyUrl'] = data.get('companyHref', "")  # 公司详情地址
            item['city'] = data.get('jobAreaString', "")  # 工作城市
            salary = data.get('provideSalaryString', "")
            item['minSalary'], item['maxSalary'], item['muchSalary'] = self.p.parse_salary(salary)  # 薪资范围
            try:
                item['workExperience'] = self.p.parse_work_experience(data.get('workYearString', ''))  # 工作经验
            except:
                item['workExperience'] = 0
            try:
                item['education'] = self.p.parse_education(data.get('degreeString', ''))  # 学历要求
            except:
                item['education'] = 0
            item['companyType'] = data.get('companyTypeString', '')  # 公司性质

            item['welfare'] = ','.join(data.get('jobTags', []))

            item['companyIndustry'] = data.get("industryType2Str", '')
            item['offsite'] = 0
            item['recruitNum'] = self.p.parse_recruit_num(data.get('jobNumString', ''))
            item['company_id'] = self.get_company_id(item)
            self.insert(item)
        if len(data_list) < 100:
            return False
        else:
            return True

    def get_company_id(self, item):
        company_id_dict = self.sql.select(self.sql_company_id % (item['companyUrl'], item['companyName']),
                                          fetch_one=True)
        if company_id_dict:
            company_id = company_id_dict.get('id', 0)
        else:
            company_id = self.sql.insert(self.sql_company, [
                item['companyName'], item['companyUrl'], item['companyType'],
                item['companyPersonNum'], item['companyIndustry'], 1, item['update_time']])
            print('公司数据录入成功'.center(100, '#'))
            if not company_id:
                company_id_dict = self.sql.select(self.sql_company_id % (item['companyUrl'], item['companyName']),
                                                  fetch_one=True)
                try:
                    company_id = company_id_dict.get('id', 0)
                except:
                    company_id = 0
        return company_id

    def insert(self, item):
        """
        入库函数
        :return:
        """
        print(self.spider_name.center(100, '='))
        # pprint(item)
        ls = [item.get('jobName'), item['minSalary'], item['maxSalary'], item['city'], item['company_id'],
              datetime.date.today().month]
        item['job_id'] = md5(''.join([str(x) for x in ls]).encode()).hexdigest()
        y = str(datetime.date.today().year)
        m = str(datetime.date.today().month).zfill(2)
        sql_job = "INSERT " + f"""INTO jobinfo_{y}{m} (jobName,minSalary,maxSalary,monthSalary,detailUrl,education,city,publishTime,
    workExperience,firstJobType,secondJobType,thirdJobType,resource,company_id,offsite,recruitNum,`status`,update_time,job_id)
    VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s);"""
        sql_job_add = "INSERT " + f""" INTO jobinfo_add_{y}{m} (id,welfare,update_time)
    VALUES (%s,%s,%s);"""
        job_id = self.sql.insert(sql_job, [
            item['jobName'], item['minSalary'], item['maxSalary'], item['muchSalary'], item['detailUrl'],
            item['education'], item['city'], item['publishTime'], item['workExperience'], item["firstJobType"],
            item['secondJobType'], item['thirdJobType'], '1', item['company_id'], item['offsite'],
            item['recruitNum'], 1, item['update_time'], item['job_id']])
        if job_id:
            self.sql.insert(sql_job_add, [job_id, item['welfare'], item['update_time']])
        print('工作数据入库成功'.center(100, '#'))

    def url_qc(self, url):
        # y = str(datetime.date.today().year)
        m = str(datetime.date.today().month).zfill(2)
        if self.m != m:
            self.url_set.clear()
            self.m = m
        url_md5 = md5(url.encode()).hexdigest()
        if url_md5 in self.url_set:
            print(f"{self.spider_name} url重复，去重".center(50, "*"))
            return True
        else:
            self.url_set.add(url_md5)
            return False

    def spider_start(self):
        y = str(datetime.date.today().year)
        m = str(datetime.date.today().month).zfill(2)
        url_list = self.sql.select("SELECT " + f"MD5(detailUrl) as url FROM `jobinfo_{y}{m}`")
        # for url in url_list:
        #     self.url_set.add(url['url'])
        self.url_set = set([url['url'] for url in url_list])


def sql_select(sql, host='10.86.0.107', user='root', password='wit123456', database="hrdatabase"):
    db = pymysql.connect(host=host, user=user, password=password, database=database, charset='utf8')  # 打开数据库连接
    cursor = db.cursor(pymysql.cursors.DictCursor)  # 使用cursor()方法获取操作游标
    try:
        cursor.execute(sql)  # 执行SQL语句
        return cursor.fetchall()  # 获取所有记录列表
    except BaseException as e:
        print("Error:", e)
    finally:
        db.close()  # 关闭数据库连接


# def list_url():
#     start_sql = "SELECT " + """ url,firstJobType,secondJobType,thirdJobType,id
#     FROM jobinfo_list WHERE is_used = 0 order by id """  # WHERE is_used <> MONTH(CURDATE()) DESC  limit 0,5000
#     start_list = sql_select(start_sql)
#     start_list.sort(key=lambda item: three_size_mapping.get(item['thirdJobType'], 10), reverse=True)
#     return start_list

def list_url():
    import_city_list = ('上海', '深圳', '广州', '武汉', '苏州', '成都', '杭州', '北京', '南京', '东莞', '宁波', '佛山', '无锡', '西安', '重庆', '合肥',
                        '长沙', '常州', '昆明', '昆山', '惠州', '珠海', '嘉兴', '南通', '青岛', '南昌', '天津', '中山', '沈阳', '郑州', '大连', '济南',
                        '福州', '厦门', '南宁', '温州', '芜湖', '常熟', '绍兴', '湖州', '江门', '扬州', '贵阳', '镇江', '哈尔滨', '盐城', '长春', '泰州',
                        '宜昌', '徐州', '金华', '台州', '肇庆', '太仓', '石家庄', '张家港', '清远', '太原', '湛江', '海口', '泉州')
    start_sql = "SELECT " + """ url,firstJobType,secondJobType,thirdJobType
    FROM jobinfo_list WHERE city in ({city_list})
    union all
    select distinct substring(url,1,7)url , '' firstJobType, '' secondJobType, '' thirdJobType from
	hrdatabase.jobinfo_list jl where city not in ({city_list})
    """  # WHERE is_used <> MONTH(CURDATE()) DESC  limit 0,5000
    start_list = sql_select(start_sql.format(city_list=','.join(repr(_) for _ in import_city_list)))

    return start_list


if __name__ == '__main__':
    S = Spider()
    S.spider_start()
    pool = threadpool.ThreadPool(1)
    url_dict = list_url()
    while True:
        print('列表页数量：', len(url_dict))
        if len(url_dict) > 0:
            job_requests = threadpool.makeRequests(S.get_list, url_dict)
            [pool.putRequest(req) for req in job_requests]
            pool.wait()
        else:
            print('暂停执行'.center(50, "*"))
            time.sleep(60)

